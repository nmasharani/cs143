################################################################################

TESTING OUR CODE GENERATOR

For this assignment, we had two testfile directories: Testfiles, which contains
tests we wrote specifically to test our code generator, and valid_testfiles_pa3, 
which contains the valid cool programs we wrote to test assignments 1-3, as a 
sanity check. 

We used a script, testscript, to automate our testing process to 
increase the volume we were able to test. The test script used diff to compare 
the outputs of cool programs compiled with our compiler and the reference. In 
all but a few cases, we found that our compiler matched the reference in output
using this script. In the few cases mentioned above, the program required user 
input, so we couldn't test them with an automated script, so we verified the 
outputs manually. We also saw that our compiler didn't match the reference 
completely--the number of instructions, reads, rights, etc. were always different,
which is probably due to the fact that our code generation implementation is
different to the reference's.

When writing our test files, we used IO to output the values of variables at 
certain critical points in the program, so that we could verify that the 
behavior was as expected. Since it is possible to have a cool program that runs
successfully and emits a success message, but that might have incorrect behavior,
we found that this printing was very important in identifying incorrect behavior. 

For more information about testing, see the descriptions of several select test 
files below.

################################################################################

DESCRIPTIONS OF TEST FILES

Due to the volume of test files we wrote, we cannot write on every single one 
of them. For more information about a file, look at the comments in a file
itself.

Note that, for ease of testing, we copied the test files from 
/usr/class/cs143/examples to our Testfiles directory.


FILE 1: Testfiles/a111_let_self_type.cl

This file tests the usage of SELF_TYPE in let statements, attributes, assignment, 
and new statements. Since SELF_TYPE is a "special case" in all of these expression 
types, we found it to be especially important to test it carefully--we had a 
few very tricky bugs that came from these special cases, and that we found 
through testing. This file also takes advantage of the built in Object method
type_name, which is pre-generated in the trap handler. Using this method requires
our stack convention to conform to the trap handler's stack convention, so this
file also tests that.

FILE 2: Testfiles/let_test.cl

This file tests the dynamic scope and stack convention in let statements. Since
let statements are part of a new scope, but we don't enter a new stack frame upon
entering a let statement, getting these statements to work correctly with the 
correct dynamic scope is tricky and important. It is also very easy for the
stack to become corrupted in the complicated implementation of let statements,
so this file also allowed us to test that. 

FILE 3: Testfiles/dispatch.cl

This file tests that dispatch of all types works correctly, with the correct stack
convention. The file tests dispatch with and without parameters, with and without
static types, and with and without expressions upon which the method is being 
called. This file also tests the order in which parameters are evaluated. 

FILE 4: Testfiles/a2_nest_case.cl

This file tests nested case statements. Like let statements, case statements are
tricky because, although they define a new scope, they don't get executed on a new
stack frame. Therefore, ensuring that the stack is preserved and that temporary 
variables aren't overwritten is extremely important. Testing these nested case
statements ensures that the stack convention is as we designed it.

FILE 5: Testfiles/case_test.cl

This file stress tests case statements to ensure that the variables go to the 
correct branch of the statement. Since we want each variable to go to the branch
that is closest to it in the inheritance tree, we can't just go with the first 
branch we see to which the variable conforms.


